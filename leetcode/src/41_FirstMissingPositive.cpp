#include "41_FirstMissingPositive.h"
#include "math.h"
#include <algorithm>
#include <queue>
#include <stack>

/***********************************************************
 * 41  第一个正整数
 * 
 *  数     3    4   -1    1    9   -5
 * 索引   [0]  [1]  [2]  [3]  [4]  [5]
 * 
 * 
 * 第一步, 这里有6个数, n为6, 把负数都变成6+1=7
 *  数     3    4    7    1    9    7
 * 索引   [0]  [1]  [2]  [3]  [4]  [5]
 * 
 * 
 * 第二步, 把数组当成哈希表, 把小于7的数字的数值当成哈希表索引号, 
 * 把索引号上的数变成负数, 代表该数字已经出现过, 所以剩下的正数的索引号就是没有出现过的数字
 * 
 * [0]号位置是3, 把[3-1]号位置变负数
 *  数     3    4   -7    1    9    7
 * 索引   [0]  [1]  [2]  [3]  [4]  [5] 
 *  
 * [1]号位置是4, 把[4-1]号位置变负数
 *  数     3    4   -7   -1    9    7
 * 索引   [0]  [1]  [2]  [3]  [4]  [5] 
 * 
 * [2]号位置是|-7|, 大于n, 不管
 * 
 * [3]号位置是|-1|, 把[1-1]号位置变负数
 *  数    -3    4   -7   -1    9    7
 * 索引   [0]  [1]  [2]  [3]  [4]  [5] 
 * 
 * [4]号位置是9, [5]号位置是7, 大于n, 不管
 * 
 * 
 * 第三步, 从索引0开始遍历, 返回第一个正数的索引
 ************************************************************/ 
int Solution41::firstMissingPositive(std::vector<int> &nums){
    int n = nums.size();

    // 第1步, 负数都可以忽略, 所以把负数都变成 n+1
    for(int i=0; i<n; i++){
        if(nums[i]<=0){
            nums[i] = n+1;
        }
    }

    // 第2步, 把数组当成哈希表来用. 
    // 遍历数组, 以当前数字为索引, 把该索引的位置变成负数, 
    // 所以正数的部分(那些索引)就是没有出现过的正数
    for(int i=0; i<n; i++){
        int idx = abs(nums[i]) - 1;
        if(nums[i]<=n){
            nums[idx] = -abs(nums[idx]);
        }
    }

    // 找出数组第一个大于0的数的索引
    for(int i=0; i<n; i++){
        if(nums[i] > 0){
            return i+1;
        }
    }

    return n+1;

}

