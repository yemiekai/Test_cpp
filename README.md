# 常用方法
## 1. 哈希表
表的存储形式是**键值对**:`key->value`，C++ 中有各种map实现了这种结构：map，unorderd_map，hash_map。  
原本STL只提供了<map>，通常用红黑树实现。由于性能优势，使用面广，有许多第三方类库提供了支持，如MSVC中的<hash_map>和Boost中的<boost/unordered_map.hpp>，后来Boost的unordered_map被吸纳进了C++11标准。

#### (1) 1.两数之和
题目描述：给你一个数组，要在数组中找到两个数`a`和`b`，相加等于`target`，返回`a`和`b`在数组中的索引。    

做法：遍历数组，假设当前遍历到的数是`x`，如果能在数组中找到 `target-x`，就成功了。  
把已经遍历过的数作为`key`加入哈希表，它的索引作为`value`。  
迭代遍历时在哈希表中查找`key`为`target-x`的值，如果找不到，说明没有匹配的，然后把当前元素`x`作为`key`加入哈希表继续迭代。  
  

## 2. 集合,滑动窗口
C++的set集合存放不重复的元素

#### (1) 3.无重复字符的最长子串

题目描述：找出不含有重复字符的 **最长子串** 的长度。

做法：设一个窗口，窗口有`head`和`end`，把`end`的元素放进set，如果set的size增加了，证明字符没有重复，`end`继续往后走，当前窗口大小为`end-head`，比较一次最大值。
  

## 3. 双指针法

#### (1) 4.寻找两个正序数组的中位数
两数组长度分别为`a`和`b`，假设两个数组已经合并，则第`(a+b)/2`个索引的位置就是中位数(注意要区分奇偶，自己解决)。  
分别用两指针指向两数组，哪个指针的数小，哪个指针就加一，直到两指针长度之和为`(a+b)/2`，结束
  

## 4. 二分法
一般用来解决时间复杂度要求为log(n)的问题

#### (1) 4.寻找两个正序数组的中位数
两数组长度分别为`a`和`b`，假设两个数组已经合并，则第`k`个索引的位置就是中位数, `k = (a+b)/2`(注意要区分奇偶，自己解决)。  
现在要找到合并数组中排名第`k`的数，用二分法的思路，首先在各自数组中找到排名`(k/2)-1`的数，那个数组的更小，就把哪个数组前`(k/2)-1`个数干掉。
运气好的时候可以干掉一半的数，就很快了。然后更新`k`的值，因为剩下的数少了。
为什么可以干掉？因为这两个排名加起来是`2 * (k/2-1) = k-2`, 比`k`要小，所以比中位数小，所以可以干掉。
  

## 5. 动态规划
动态规划需要注意规划顺序, 要先规划范围小的, 因为判断大的状态要利用到所包含的,最近的一个小的范围

#### (1) 5.最长回文子串  
先规划所有长度为1的子串...  保存状态
再规划所有长度为2的子串...  保存状态